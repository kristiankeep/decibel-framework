<?php
//
// Copyright (c) 2008-2016 Decibel Technology Limited.
//
namespace app\decibel\debug;

use JsonSerializable;

/**
 * Generates a backtrace and provides associated functionality.
 *
 * @author    Timothy de Paris
 */
class DBacktrace implements DDebuggable, JsonSerializable
{
    /**
     * 'args' component array key for PHP backtraces.
     *
     * @var        string
     */
    const BACKTRACE_ARGS = 'args';

    /**
     * 'class' component array key for PHP backtraces.
     *
     * @var        string
     */
    const BACKTRACE_CLASS = 'class';

    /**
     * 'file' component array key for PHP backtraces.
     *
     * @var        string
     */
    const BACKTRACE_FILE = 'file';

    /**
     * 'function' component array key for PHP backtraces.
     *
     * @var        string
     */
    const BACKTRACE_FUNCTION = 'function';

    /**
     * 'line' component array key for PHP backtraces.
     *
     * @var        string
     */
    const BACKTRACE_LINE = 'line';

    /**
     * 'type' component array key for PHP backtraces.
     *
     * @var        string
     */
    const BACKTRACE_TYPE = 'type';

    /**
     * List of classes that will always be excluded from a backtrace.
     *
     * @var        array
     */
    private static $excludedClasses = array(
        DBacktrace::class,
        DDebug::class,
        DError::class,
        DErrorHandler::class,
        DException::class,
    );

    /**
     * List of functions that will always be excluded from a backtrace.
     *
     * @var        array
     */
    private static $excludedFunctions = array(
        'assert',
        'include_once',
        'trigger_error',
    );

    /**
     * Original output of the PHP debug_backtrace() function.
     *
     * This output is stored until the trace is required, at which point
     * it is processed and converted into {@link DStackFrame} objects.
     *
     * @var        array
     */
    private $phpTrace;

    /**
     * The backtrace information.
     *
     * @var        array
     */
    private $trace;

    /**
     * Creates a new {@link DBacktrace} object.
     *
     * @return    static
     */
    public function __construct()
    {
        $this->phpTrace = debug_backtrace();
    }

    /**
     * Returns a string representation of the backtrace.
     *
     * @return    string
     */
    public function __toString()
    {
        $backtraceString = '';
        foreach ($this->getTrace() as $step => $frame) {
            /* @var $frame DStackFrame */
            $backtraceString .= "#{$step} {$frame}\n";
        }
        $backtraceString .= "#{$step} {main}";

        return $backtraceString;
    }

    /**
     * Provides debugging output for this object.
     *
     * @return    string
     */
    public function generateDebug()
    {
        return (string)$this;
    }

    /**
     * Creates a new {@link DBacktrace} object.
     *
     * @return    static
     */
    public static function create()
    {
        return new DBacktrace();
    }

    /**
     * Generates a normalised backtrace array.
     *
     * @param    array $phpTrace Trace generated by debug_backtrace()
     *
     * @return    array
     */
    protected static function &generateBacktrace($phpTrace)
    {
        // Get PHP backtrace information.
        $backtrace = array();
        foreach ($phpTrace as $trace) {
            // Set default trace information.
            set_default($trace[ self::BACKTRACE_ARGS ], array());
            set_default($trace[ self::BACKTRACE_CLASS ], null);
            set_default($trace[ self::BACKTRACE_FILE ], null);
            set_default($trace[ self::BACKTRACE_TYPE ], null);
            set_default($trace[ self::BACKTRACE_LINE ], null);
            // Ignore error handling classes.
            if (!self::includeClassInBacktrace($trace[ self::BACKTRACE_CLASS ])
                // Ignore error handling functions.
                || !self::includeFunctionInBacktrace($trace[ self::BACKTRACE_FUNCTION ])
            ) {
                continue;
            }
            $backtrace[] = DStackFrame::create(
                $trace[ self::BACKTRACE_FILE ],
                (int)$trace[ self::BACKTRACE_LINE ],
                $trace[ self::BACKTRACE_FUNCTION ],
                $trace[ self::BACKTRACE_ARGS ],
                $trace[ self::BACKTRACE_CLASS ],
                $trace[ self::BACKTRACE_TYPE ]
            );
        }

        return $backtrace;
    }

    /**
     * Generates the trace (if this is the first call) and returns it.
     *
     * @return    array    List of {@link DStrackFrame} objects.
     */
    protected function &getTrace()
    {
        if ($this->trace === null) {
            $this->trace = self::generateBacktrace($this->phpTrace);
            $this->phpTrace = null;
        }

        return $this->trace;
    }

    /**
     * Returns the stack frame at the specified depth within this backtrace.
     *
     * @param    int $depth
     *
     * @return    DStackFrame
     * @throws    DInvalidStackFrameException    If no stack frame exists at the
     *                                        requested depth.
     */
    public function getStackFrame($depth)
    {
        $trace =& $this->getTrace();
        if (isset($trace[ $depth ])) {
            return $trace[ $depth ];
        }
        throw new DInvalidStackFrameException($depth);
    }

    /**
     * Checks whether the specified class should be included in a backtrace.
     *
     * @param    string $class Name of the class to check.
     *
     * @return    bool
     */
    protected static function includeClassInBacktrace($class)
    {
        if (in_array($class, self::$excludedClasses)) {
            $include = false;
        } else {
            $include = !is_subclass_of($class, DException::class);
        }

        return $include;
    }

    /**
     * Checks whether the specified function should be included in a backtrace.
     *
     * @param    string $function Name of the function to check.
     *
     * @return    bool
     */
    protected static function includeFunctionInBacktrace($function)
    {
        return !in_array($function, self::$excludedFunctions);
    }

    /**
     * Returns a copy of this object ready for encoding into json format.
     *
     * @return    string
     */
    public function jsonSerialize()
    {
        return (string)$this;
    }
}
